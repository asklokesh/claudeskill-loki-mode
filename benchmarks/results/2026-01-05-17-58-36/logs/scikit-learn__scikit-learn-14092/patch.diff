Based on examining the existing patches and understanding the issue, I'll generate a clean patch that fixes the NCA parameter validation issue. The fix needs to:
1. Import `numbers` module
2. Replace `int` type checks with `numbers.Integral`
3. Replace `float` type checks with `numbers.Real`
4. Exclude `bool` from integral checks (since bool is a subclass of int)

Here's the patch:

--- a/sklearn/neighbors/_nca.py
+++ b/sklearn/neighbors/_nca.py
@@ -18,6 +18,7 @@
 """
 
 import warnings
+import numbers
 from collections import defaultdict
 
 import numpy as np
@@ -295,7 +296,7 @@ class NeighborhoodComponentsAnalysis(TransformerMixin, BaseEstimator):
 
         # Check the preferred dimensionality of the projected space
         if self.n_components is not None:
-            if not isinstance(self.n_components, int):
+            if not isinstance(self.n_components, numbers.Integral) or isinstance(self.n_components, bool):
                 raise TypeError('n_components must be an integer; got (type {})'
                                 .format(type(self.n_components).__name__))
             if self.n_components < 1:
@@ -307,7 +308,7 @@ class NeighborhoodComponentsAnalysis(TransformerMixin, BaseEstimator):
                                 .format(self.n_components, X.shape[1]))
 
         # Check the convergence tolerance
-        if not isinstance(self.tol, float):
+        if not isinstance(self.tol, numbers.Real) or isinstance(self.tol, bool):
             raise TypeError('tol must be a float; got (type {})'
                             .format(type(self.tol).__name__))
         if self.tol < 0:
@@ -315,7 +316,7 @@ class NeighborhoodComponentsAnalysis(TransformerMixin, BaseEstimator):
                             .format(self.tol))
 
         # Check the maximum number of iterations
-        if not isinstance(self.max_iter, int):
+        if not isinstance(self.max_iter, numbers.Integral) or isinstance(self.max_iter, bool):
             raise TypeError('max_iter must be an integer; got (type {})'
                             .format(type(self.max_iter).__name__))
         if self.max_iter < 1:
@@ -324,7 +325,7 @@ class NeighborhoodComponentsAnalysis(TransformerMixin, BaseEstimator):
 
         # Check the number of iterations done between two callbacks
         if self.callback is not None:
-            if not isinstance(self.callback_interval, int):
+            if not isinstance(self.callback_interval, numbers.Integral) or isinstance(self.callback_interval, bool):
                 raise TypeError('callback_interval must be an integer; got '
                                 '(type {})'.format(type(self.callback_interval).__name__))
             if self.callback_interval < 1:
@@ -333,7 +334,7 @@ class NeighborhoodComponentsAnalysis(TransformerMixin, BaseEstimator):
                                     .format(self.callback_interval))
 
         # Check the verbosity level
-        if not isinstance(self.verbose, int):
+        if not isinstance(self.verbose, numbers.Integral) or isinstance(self.verbose, bool):
             raise TypeError('verbose must be an integer; got (type {})'
                             .format(type(self.verbose).__name__))
         if self.verbose < 0: