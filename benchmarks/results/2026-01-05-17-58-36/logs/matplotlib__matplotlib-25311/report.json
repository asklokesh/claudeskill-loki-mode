{
  "instance_id": "matplotlib__matplotlib-25311",
  "model_name_or_path": "loki-mode-sonnet",
  "model_patch": "Based on the issue description and my exploration, I need to create a patch that adds `__getstate__` and `__setstate__` methods to the draggable classes to handle pickling. Let me generate the patch:\n\n--- a/lib/matplotlib/legend.py\n+++ b/lib/matplotlib/legend.py\n@@ -1160,6 +1160,24 @@ class Legend(Artist):\n             self._draggable = None\n         return self._draggable\n \n+    def __getstate__(self):\n+        state = self.__dict__.copy()\n+        # Store draggable state for restoration after unpickling\n+        if self._draggable is not None:\n+            state['_was_draggable'] = {\n+                'use_blit': self._draggable._use_blit,\n+                'update': self._draggable._update,\n+            }\n+        # Remove unpicklable draggable object\n+        state['_draggable'] = None\n+        return state\n+\n+    def __setstate__(self, state):\n+        draggable_state = state.pop('_was_draggable', None)\n+        self.__dict__.update(state)\n+        if draggable_state is not None:\n+            self.set_draggable(True, **draggable_state)\n+\n \n class DraggableLegend(DraggableOffsetBox):\n     def __init__(self, legend, use_blit=False, update=\"loc\"):\n--- a/lib/matplotlib/offsetbox.py\n+++ b/lib/matplotlib/offsetbox.py\n@@ -997,11 +997,36 @@ class DraggableBase:\n \n     def disconnect(self):\n         \"\"\"Disconnect the callbacks.\"\"\"\n-        for cid in self.cids:\n-            self.canvas.mpl_disconnect(cid)\n+        if self.ref_artist.figure is not None:\n+            for cid in self.cids:\n+                self.canvas.mpl_disconnect(cid)\n         self.cids.clear()\n         self.got_artist = False\n \n+    def __getstate__(self):\n+        state = self.__dict__.copy()\n+        # Remove unpicklable attributes\n+        # canvas is a property, so it's not in __dict__\n+        state['cids'] = []\n+        # Store the draggable configuration for restoration\n+        state['_use_blit_saved'] = self._use_blit\n+        state['_update_saved'] = self._update\n+        return state\n+\n+    def __setstate__(self, state):\n+        # Restore saved configuration\n+        use_blit = state.pop('_use_blit_saved', False)\n+        update = state.pop('_update_saved', 'loc')\n+        self.__dict__.update(state)\n+        # Reinitialize with saved configuration\n+        self._use_blit = use_blit\n+        self._update = update\n+        # Don't reconnect callbacks immediately - they will be reconnected\n+        # when the figure is next displayed or when explicitly re-enabled\n+        if not self.cids:\n+            # Re-establish the connections\n+            self.connect()\n+\n+\n class DraggableOffsetBox(DraggableBase):\n     def __init__(self, ref_artist, offsetbox, use_blit=False):\n         super().__init__(ref_artist, use_blit=use_blit)\n--- a/lib/matplotlib/text.py\n+++ b/lib/matplotlib/text.py\n@@ -2468,6 +2468,24 @@ class Annotation(Text, _AnnotationBase):\n             self._draggable.disconnect()\n         self._draggable = None\n \n+    def __getstate__(self):\n+        state = self.__dict__.copy()\n+        # Store draggable state for restoration after unpickling\n+        if self._draggable is not None:\n+            state['_was_draggable'] = {\n+                'use_blit': self._draggable._use_blit,\n+            }\n+        # Remove unpicklable draggable object\n+        state['_draggable'] = None\n+        return state\n+\n+    def __setstate__(self, state):\n+        draggable_state = state.pop('_was_draggable', None)\n+        self.__dict__.update(state)\n+        if draggable_state is not None:\n+            self.set_draggable(True, **draggable_state)\n+\n+\n class _AnnotationBase:\n     def __init__(self,\n                  xy,",
  "attempts": 1,
  "success": true,
  "error": null,
  "timestamp": "2026-01-05T19:41:59.229681"
}