{
  "instance_id": "django__django-15819",
  "model_name_or_path": "loki-mode-sonnet",
  "model_patch": "This appears to be the claudeskill-loki-mode repository, not a Django repository. For this SWE-bench task, I need to generate a patch for the Django repository based on the architect's analysis. Let me create the patch directly based on the standard Django repository structure.\n\n--- a/django/core/management/commands/inspectdb.py\n+++ b/django/core/management/commands/inspectdb.py\n@@ -1,6 +1,7 @@\n import keyword\n import re\n from collections import OrderedDict\n+from collections import Counter\n \n from django.core.management.base import BaseCommand, CommandError\n from django.db import DEFAULT_DB_ALIAS, connections\n@@ -63,6 +64,7 @@ class Command(BaseCommand):\n                 yield \"# Unable to inspect table '%s'\" % table_name\n                 continue\n             column_to_field_name = self.normalize_col_names(\n+                table_name,\n                 row[0], used_column_names, is_relation\n             )\n             yield from self.get_meta(table_name, constraints, column_to_field_name, is_view, is_partition)\n@@ -89,11 +91,25 @@ class Command(BaseCommand):\n             used_column_names = {}  # Holds column names used in the table so far\n             for row in table_description:\n                 comment_notes = []  # Holds Field notes, to be displayed in a Python comment.\n                 extra_params = OrderedDict()  # Holds Field parameters such as 'db_column'.\n                 column_name = row[0]\n                 is_relation = column_name in relations\n+                \n+                # Track relations to detect multiple FKs to same table\n+                if not hasattr(self, '_relation_counts'):\n+                    self._relation_counts = {}\n+                if table_name not in self._relation_counts:\n+                    self._relation_counts[table_name] = Counter()\n+                    for rel_column in relations:\n+                        rel_table = relations[rel_column][1]\n+                        self._relation_counts[table_name][rel_table] += 1\n+                \n                 att_name, params, notes = self.normalize_col_names(\n+                    table_name, column_name, used_column_names, is_relation\n+                )\n+                \n+                # Add related_name if multiple FKs point to same table\n+                if is_relation:\n+                    rel_table = relations[column_name][1]\n+                    if self._relation_counts[table_name][rel_table] > 1:\n+                        extra_params['related_name'] = '%s_set' % att_name\n+                \n                 extra_params.update(params)\n                 comment_notes.extend(notes)\n \n@@ -187,7 +203,7 @@ class Command(BaseCommand):\n \n         return table2model(table_name)\n \n-    def normalize_col_names(self, col_name, used_column_names, is_relation):\n+    def normalize_col_names(self, table_name, col_name, used_column_names, is_relation):\n         \"\"\"\n         Modify the column name to make it a valid Python identifier.\n         \"\"\"",
  "attempts": 1,
  "success": true,
  "error": null,
  "timestamp": "2026-01-05T19:13:58.474279"
}