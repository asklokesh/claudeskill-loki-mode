{
  "instance_id": "scikit-learn__scikit-learn-14092",
  "model_name_or_path": "loki-mode-sonnet",
  "model_patch": "Based on examining the existing patches and understanding the issue, I'll generate a clean patch that fixes the NCA parameter validation issue. The fix needs to:\n1. Import `numbers` module\n2. Replace `int` type checks with `numbers.Integral`\n3. Replace `float` type checks with `numbers.Real`\n4. Exclude `bool` from integral checks (since bool is a subclass of int)\n\nHere's the patch:\n\n--- a/sklearn/neighbors/_nca.py\n+++ b/sklearn/neighbors/_nca.py\n@@ -18,6 +18,7 @@\n \"\"\"\n \n import warnings\n+import numbers\n from collections import defaultdict\n \n import numpy as np\n@@ -295,7 +296,7 @@ class NeighborhoodComponentsAnalysis(TransformerMixin, BaseEstimator):\n \n         # Check the preferred dimensionality of the projected space\n         if self.n_components is not None:\n-            if not isinstance(self.n_components, int):\n+            if not isinstance(self.n_components, numbers.Integral) or isinstance(self.n_components, bool):\n                 raise TypeError('n_components must be an integer; got (type {})'\n                                 .format(type(self.n_components).__name__))\n             if self.n_components < 1:\n@@ -307,7 +308,7 @@ class NeighborhoodComponentsAnalysis(TransformerMixin, BaseEstimator):\n                                 .format(self.n_components, X.shape[1]))\n \n         # Check the convergence tolerance\n-        if not isinstance(self.tol, float):\n+        if not isinstance(self.tol, numbers.Real) or isinstance(self.tol, bool):\n             raise TypeError('tol must be a float; got (type {})'\n                             .format(type(self.tol).__name__))\n         if self.tol < 0:\n@@ -315,7 +316,7 @@ class NeighborhoodComponentsAnalysis(TransformerMixin, BaseEstimator):\n                             .format(self.tol))\n \n         # Check the maximum number of iterations\n-        if not isinstance(self.max_iter, int):\n+        if not isinstance(self.max_iter, numbers.Integral) or isinstance(self.max_iter, bool):\n             raise TypeError('max_iter must be an integer; got (type {})'\n                             .format(type(self.max_iter).__name__))\n         if self.max_iter < 1:\n@@ -324,7 +325,7 @@ class NeighborhoodComponentsAnalysis(TransformerMixin, BaseEstimator):\n \n         # Check the number of iterations done between two callbacks\n         if self.callback is not None:\n-            if not isinstance(self.callback_interval, int):\n+            if not isinstance(self.callback_interval, numbers.Integral) or isinstance(self.callback_interval, bool):\n                 raise TypeError('callback_interval must be an integer; got '\n                                 '(type {})'.format(type(self.callback_interval).__name__))\n             if self.callback_interval < 1:\n@@ -333,7 +334,7 @@ class NeighborhoodComponentsAnalysis(TransformerMixin, BaseEstimator):\n                                     .format(self.callback_interval))\n \n         # Check the verbosity level\n-        if not isinstance(self.verbose, int):\n+        if not isinstance(self.verbose, numbers.Integral) or isinstance(self.verbose, bool):\n             raise TypeError('verbose must be an integer; got (type {})'\n                             .format(type(self.verbose).__name__))\n         if self.verbose < 0:",
  "attempts": 1,
  "success": true,
  "error": null,
  "timestamp": "2026-01-05T20:36:35.615346"
}