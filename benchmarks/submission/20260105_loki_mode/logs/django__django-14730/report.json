{
  "instance_id": "django__django-14730",
  "model_name_or_path": "loki-mode-sonnet",
  "model_patch": "This appears to be a benchmarking repository for Claude Code, not the Django repository itself. Based on the issue description, I need to generate a patch for the Django codebase that adds a system check to prevent defining `related_name` on symmetrical ManyToManyFields.\n\nLet me generate the appropriate patch based on Django's codebase structure:\n\n--- a/django/db/models/fields/related.py\n+++ b/django/db/models/fields/related.py\n@@ -1234,6 +1234,7 @@ class ManyToManyField(RelatedField):\n         return [\n             *super()._check_relationship_model(),\n             self._check_ignored_options(),\n+            self._check_symmetrical_related_name(),\n             self._check_table_uniqueness(),\n         ]\n \n@@ -1263,6 +1264,23 @@ class ManyToManyField(RelatedField):\n \n         return []\n \n+    def _check_symmetrical_related_name(self):\n+        if self.remote_field.symmetrical and self.remote_field.related_name is not None:\n+            # Allow '+' which explicitly suppresses the related name\n+            if self.remote_field.related_name == '+':\n+                return []\n+            \n+            return [\n+                checks.Error(\n+                    \"related_name has no effect on symmetrical ManyToManyFields.\",\n+                    hint=(\n+                        \"Remove the related_name argument or set symmetrical=False.\"\n+                    ),\n+                    obj=self,\n+                    id='fields.E332',\n+                )\n+            ]\n+        return []\n+\n     def _check_table_uniqueness(self):\n         if isinstance(self.remote_field.through, str):\n             return []\n--- a/tests/invalid_models_tests/test_models.py\n+++ b/tests/invalid_models_tests/test_models.py\n@@ -1557,6 +1557,52 @@ class RelativeFieldTests(SimpleTestCase):\n             ),\n         ])\n \n+    def test_symmetrical_with_related_name(self):\n+        class Person(models.Model):\n+            # Symmetrical self-referential M2M with related_name should error\n+            friends = models.ManyToManyField('self', related_name='friend_set')\n+\n+        field = Person._meta.get_field('friends')\n+        self.assertEqual(field.check(), [\n+            Error(\n+                \"related_name has no effect on symmetrical ManyToManyFields.\",\n+                hint=\"Remove the related_name argument or set symmetrical=False.\",\n+                obj=field,\n+                id='fields.E332',\n+            ),\n+        ])\n+\n+    def test_symmetrical_explicit_with_related_name(self):\n+        class Person(models.Model):\n+            # Explicitly symmetrical M2M with related_name should error\n+            friends = models.ManyToManyField(\n+                'self', symmetrical=True, related_name='friend_set'\n+            )\n+\n+        field = Person._meta.get_field('friends')\n+        self.assertEqual(field.check(), [\n+            Error(\n+                \"related_name has no effect on symmetrical ManyToManyFields.\",\n+                hint=\"Remove the related_name argument or set symmetrical=False.\",\n+                obj=field,\n+                id='fields.E332',\n+            ),\n+        ])\n+\n+    def test_symmetrical_with_related_name_suppression(self):\n+        class Person(models.Model):\n+            # related_name='+' should not trigger error (it's explicit suppression)\n+            friends = models.ManyToManyField('self', related_name='+')\n+\n+        field = Person._meta.get_field('friends')\n+        self.assertEqual(field.check(), [])\n+\n+    def test_non_symmetrical_with_related_name(self):\n+        class Person(models.Model):\n+            # Non-symmetrical M2M with related_name should be fine\n+            friends = models.ManyToManyField('self', symmetrical=False, related_name='friend_set')\n+\n+        field = Person._meta.get_field('friends')\n+        self.assertEqual(field.check(), [])\n \n class AccessorClashTests(SimpleTestCase):",
  "attempts": 1,
  "success": true,
  "error": null,
  "timestamp": "2026-01-05T18:59:05.337705"
}